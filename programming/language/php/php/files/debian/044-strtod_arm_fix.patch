--- a/Zend/zend_strtod.c
+++ b/Zend/zend_strtod.c
@@ -152,14 +152,25 @@ typedef unsigned long int uint32_t;
 #define IEEE_LITTLE_ENDIAN
 #endif
 
-#if defined(__arm__) && !defined(__VFP_FP__)
-/*
- *  * Although the CPU is little endian the FP has different
- *   * byte and word endianness. The byte order is still little endian
- *    * but the word order is big endian.
- *     */
-#define IEEE_BIG_ENDIAN
+#if defined(__arm__) || defined(__thumb__)
+/* ARM traditionally used big-endian words; and within those words the
+   byte ordering was big or little endian depending upon the target.
+   Modern floating-point formats are naturally ordered; in this case
+   __VFP_FP__ will be defined, even if soft-float. */
 #undef IEEE_LITTLE_ENDIAN
+#undef IEEE_BIG_ENDIAN
+#if defined(__VFP_FP__) || defined(__MAVERICK__)
+# ifdef __ARMEL__
+#  define IEEE_LITTLE_ENDIAN
+# else
+#  define IEEE_BIG_ENDIAN
+# endif
+#else
+# define IEEE_BIG_ENDIAN
+# ifdef __ARMEL__
+#  define IEEE_BYTES_LITTLE_ENDIAN
+# endif
+#endif
 #endif
 
 #ifdef __vax__
@@ -267,8 +278,7 @@ BEGIN_EXTERN_C()
 
 #if defined(IEEE_LITTLE_ENDIAN) + defined(IEEE_BIG_ENDIAN) + defined(VAX) + \
 		    defined(IBM) != 1
-	Exactly one of IEEE_LITTLE_ENDIAN IEEE_BIG_ENDIAN, VAX, or
-	IBM should be defined.
+#error "Exactly one of IEEE_LITTLE_ENDIAN IEEE_BIG_ENDIAN, VAX, or IBM should be defined."
 #endif
 
 	typedef union {
@@ -288,7 +298,7 @@ BEGIN_EXTERN_C()
  * An alternative that might be better on some machines is
  * #define Storeinc(a,b,c) (*a++ = b << 16 | c & 0xffff)
  */
-#if defined(IEEE_LITTLE_ENDIAN) + defined(VAX) + defined(__arm__)
+#if defined(IEEE_LITTLE_ENDIAN) + defined(VAX) + defined(IEEE_BYTES_LITTLE_ENDIAN)
 #define Storeinc(a,b,c) (((unsigned short *)a)[1] = (unsigned short)b, \
 		((unsigned short *)a)[0] = (unsigned short)c, a++)
 #else
